module main

import v.ast
import v.parser
import v.pref
import v.token
import v.util
import v.errors
import v.checker
import v.table
import os
import strings
import lsp
import net.urllib
import json

struct LangFeat {
pub mut:
    files map[string]ast.File
    prefs  &pref.Preferences
    table &table.Table
    checker checker.Checker
}

// https://github.com/microsoft/vscode-uri/blob/7c094c53581a8b1b7631fbc5c4265dea2beaf303/src/index.ts#L749
fn uri_file(f_path string) urllib.URL {
    mut path := f_path
    mut authority := ''

    if os.user_os() == 'windows' {
        path = path.replace('\\', '/')
    }

    if path[0] == `/` && path[1] == `/` {
        if idx := path[2..].index('/') {
            authority = path[2..(idx+2)]
            path = path[2..]

            if path.len == 0 {
                path = '/'
            }
        } else {
            authority = path[2..]
            path = '/'
        }
    }

    uri := urllib.parse('file://${authority}${path}') or {
        return urllib.URL{
            scheme: 'file',
            host: '',
            path: '',
            user: &urllib.Userinfo{}
        }
    }

    return uri
}

fn to_pos(file_path string, pos token.Position) lsp.Position {
    source := util.read_file(file_path) or {''}
    mut p := util.imax(0, util.imin(source.len - 1, pos.pos))
    column := util.imax(0, pos.pos - p - 1)
    return lsp.Position{ line: pos.line_nr+1, character: util.imax(1, column+1) }
}

fn to_range(file_path string, pos token.Position) lsp.Range {
    start_pos := to_pos(file_path, pos)
    end_pos := { start_pos | character: start_pos.character+(pos.len-1) }
    range := lsp.Range{ start: start_pos, end: end_pos }

    return range
}

fn provide_symbols(file_path string, stmts []ast.Stmt) []lsp.DocumentSymbol {
    mut symbols := []lsp.DocumentSymbol{}

    for stmt in stmts {
        if stmt is ast.StructDecl {
            stc := stmt as ast.StructDecl
            stc_range := to_range(file_path, stc.pos)
            symbols << lsp.DocumentSymbol{
                name: stc.name,
                detail: '', // TODO
                kind: 23,
                deprecated: stc.attr == 'deprecated',
                range: stc_range,
                selection_range: stc_range
            }
        }

        if stmt is ast.AssignStmt {
            a := stmt as ast.AssignStmt
            for id in a.left {
                id_range := to_range(file_path, id.pos)
                symbols << lsp.DocumentSymbol{
                    name: id.name,
                    detail: '',
                    kind: 13,
                    deprecated: false,
                    range: id_range,
                    selection_range: id_range
                }
            }
        }

        if stmt is ast.FnDecl {
            fnd := stmt as ast.FnDecl
            fndr := to_range(file_path, fnd.pos)
            mut sym := lsp.DocumentSymbol{
                name: fnd.name,
                detail: '',
                kind: 12,
                deprecated: fnd.is_deprecated,
                range: fndr,
                selection_range: fndr,
                children: []
            }

            // receiver
            if fnd.receiver.name.len > 0 {
                rec_pos := to_range(file_path, fnd.receiver_pos)
                sym.children << lsp.DocumentSymbol{
                    name: fnd.receiver.name,
                    detail: '',
                    kind: 13,
                    deprecated: false,
                    range: rec_pos,
                    selection_range: rec_pos
                }
            }

            for arg in fnd.args {
                sym.children << lsp.DocumentSymbol{
                    name: arg.name,
                    detail: ''
                    kind: 13,
                    deprecated: false,
                    range: fndr,
                    selection_range: fndr
                }
            }

            sym.children << provide_symbols(file_path, fnd.stmts)
            symbols << sym
        } 
    }

    return symbols
}

fn (lf LangFeat) provide_doc_symbols(file_path string) []lsp.DocumentSymbol {
    mut symbols := []lsp.DocumentSymbol{}

    for _, file_ast in lf.files {
        symbols << provide_symbols(file_ast.path, file_ast.stmts)
    }

    return symbols
}

fn to_diag_warning(w errors.Warning) lsp.Diagnostic {
    w_range := to_range(w.file_path, w.pos)
    return lsp.Diagnostic{
        range: w_range,
        severity: 2,
        source: w.reporter.str(),
        message: w.message,
        related_information: [
            lsp.DiagnosticRelatedInformation{
                location: lsp.Location{
                    uri: uri_file(w.file_path).str(),
                    range: w_range
                },
                message: ''
            }
        ]
    }
}

fn to_diag_error(e errors.Error) lsp.Diagnostic {
    e_range := to_range(e.file_path, e.pos)
    return lsp.Diagnostic{
        range: e_range,
        severity: 1,
        source: e.reporter.str(),
        message: e.message,
        related_information: [
            lsp.DiagnosticRelatedInformation{
                location: lsp.Location{
                    uri: uri_file(e.file_path).str(),
                    range: e_range
                },
                message: ''
            }
        ]
    }
}

fn (lf mut LangFeat) publish_diagnostics(file_path string) lsp.PublishDiagnosticsParams {    
    lf.checker.errors = []errors.Error{}
    lf.checker.warnings = []errors.Warning{}
    mut diag := []lsp.Diagnostic{}
    file := lf.files[file_path]
    lf.checker.check(file)
    for w in file.warnings { diag << to_diag_warning(w) }
    for e in file.errors { diag << to_diag_error(e) }
    for w in lf.checker.warnings { diag << to_diag_warning(w) }
    for e in lf.checker.errors { diag << to_diag_error(e) }

    return lsp.PublishDiagnosticsParams{
        uri: uri_file(file.path).str(),
        diagnostics: diag
    }
}

fn new_lf() LangFeat {
    mut lf := LangFeat{
        table: table.new_table(),
        prefs: &pref.Preferences{ output_mode: .silent }
    }

    lf.checker = checker.new_checker(lf.table, lf.prefs)

    return lf
}

fn (mut lf LangFeat) analyze(file_path string) {
    base_path := os.real_path(os.base_dir(file_path))
    files := os.ls(base_path) or { panic(err) }
    filtered_files := lf.prefs.should_compile_filtered_files(base_path, files)

    for file in filtered_files {
        fscope := &ast.Scope{ parent: 0 }
        file_ast := parser.parse_file(file, lf.table, .skip_comments, lf.prefs, fscope)

        lf.files[file] = file_ast
    }
}

fn (mut lf LangFeat) hover(file_path string, pos lsp.Position) lsp.Hover {
    // TODO
}

fn main() {
    mut lf := new_lf()
    abs_path := os.real_path(os.args[1])
    lf.analyze(abs_path)
    // diags := lf.publish_diagnostics(abs_path)
    // syms := lf.provide_doc_symbols(abs_path)
    
    // println(json.encode(diags))
}